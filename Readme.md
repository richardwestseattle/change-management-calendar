jQuery/JavaScript Change Management Calendar | Richard West | https://www.linkedin.com/in/richardwestseattle/

This JavaScript/jQuery calendar was built to display IT change requests in a helpful format, to help with change management processes and planning. The idea is that a technician, and/or change manager, can view: what changes have occurred in the past few days; what changes are planned; and what change requests are queued up for review.

The data retrieval function was built to obtain data in an environment where the data is written to HTML first, and then retrieved & parsed afterward (see the retrieveData() function, and calendarElements array). The data retrieval function scans for items with a specific class ('changeRecord'), and then pulls values from their various child elements; selected by class as well. This function would need to be modified if data were obtained in a different format, i.e. JSON, XML, etc.

The calendar renderer (renderCalendar()) sorts the calendar and stores it in a new array called sortedCalendar. The renderCalendar() sets a start date, and end date, and then renders the calendar one day at a time. For IT change management, I set the range to [today - 7 days] ==> [today + 14 days]. In this demo, the range is July 7, 2018 +/-10 days, as is the dummy data set (data.html).

As each day renders, the sorted array of events (sortedCalendar) is scanned by a separate function called getTodaysEvents(), to determine which events could potentially affect the day in focus (focusDate). This includes events that start prior to the day in focus, so long as they extend to overlap the day in focus. Individual events are rendered by the renderEvent() function and passed back to getTodaysEvents() as HTML. Events noted as starting on the focus day (|), prior to the focus day (<=|), and whether or not they end on the focus day (|), or beyond midnight (|=>) (see: tomorrowDate). To improve efficiency, when an item is determined to be completed, it is marked as such in the array, so it is not evaluated in subsequent $.each() rendering loops (see: ['includeMe'] = true/false). As the rendering of the day in focus completes, it's HTML is passed back to the renderCalendar() function and is appended to the growing HTML string. Then, renderCalendar() advances to the next day, until the range is fully rendered. When the function terminates, the entire HTML string is appended to the calendar <TABLE>.

Example: renderCalendar() loops through the days in range, for each day => getTodaysEvents() gets all the events affecting today. For each item => renderEvent() renders the HTML. HTML is passed back up the chain in reverse order, and appended to a string, until loop termination.

Filtering checkbox values for different types of change, statuses, and service providers are stored in local storage in the browser. I did this so that if the calendar were used with a frequently updated data set, a refresh interval could be set, and filtering preferences would persist. Statuses and types of change are static, because they are known for my purposes. Service provider checkboxes are dynamic and are determined and rendered on the fly, based on what events are occurring on the calendar, and which service owners are responsible for providing them. When page rendering is complete, event handlers are bound to the checkboxes so that whenever any of them change in value, the visibilityEvaluator() is run. This function sets every item that meets the criteria to $.show(), and sets everything else to $.hide(). The visibilityEvaluator() also unchecks any boxes used for email sharing to prevent user frustration/confusion when inadvertently sharing items that are filtered out of view.

The CSS is fairly self-explanatory. I have not yet implemented styles for many of the elements that are classed and id'd, but I built it so that it would be fairly easy to modify the styling to suit user preferences.
