jQuery/JavaScript Change Management Calendar | Richard West | rick.p.west@gmail.com

This JavaScript/jQuery calendar was built to display IT change requests in a useful format, in the interest of improving change management processes and planning. The idea is that a technician, and/or change manager, can see: what changes have occurred in the past few days; what changes are planned; and what change requests are queued up for review.

You could take the core components of this and modify the data retrieval method to fetch data from any available source via AJAX, REST, or wherever you get it from, and then modify the date parser to suit the date format in your dataset. Unfortunately, in my case, I am  working in an environment where the data must be written to HTML, and then retrieved & parsed afterward (see the retrieveData() function, and calendarElements array) because this piece of the environment is beyond reach. I am able to apply classes to the data, so the data retrieval function scans for items with a specific class (changeRecord), and then pulls values from their various child elements; selected by class as well. This function would need to be modified if data were obtained in a different format, i.e. JSON, XML, etc.

The calendar renderer (renderCalendar()) sorts the calendar and stores it in a new array called sortedCalendar. The renderCalendar() sets a start date, and end date, and then renders the calendar one day at a time. For IT change management, I set the range to [today - 7 days] ==> [today + 14 days]. In this demo, the range is July 7, 2018 +/-10 days, as is the dummy data set (data.html). If you want more data, there is an Excel file included (HTML Data Grid with Dummy Data.xlsx) that I created  for generating nonsense via random numbers and lookups for the sake of demonstration.

As each day renders, the sorted array of events (sortedCalendar) is scanned by a separate function called getTodaysEvents(), to determine which events could potentially affect the day in focus (focusDate). This includes events that start prior to the day in focus, so long as they extend to overlap the day in focus. Individual events are rendered by the renderEvent() function and passed back to getTodaysEvents() as HTML. Events noted as starting on the focus day (|), prior to the focus day (<=|), and whether or not they end on the focus day (|), or beyond midnight (|=>) (see: tomorrowDate). To improve efficiency, when an item is determined to be completed, it is marked as such in the array, so it is not evaluated in subsequent $.each() rendering loops (see: ['includeMe'] = true/false). As the rendering of the day in focus completes, it's HTML is passed back to the renderCalendar() function and is appended to the growing HTML string. Then, renderCalendar() advances to the next day, until the range is fully rendered. When the function terminates, the entire HTML string is appended to the calendar <TABLE>.

Like this: renderCalendar() loops through the days in range, for each day => getTodaysEvents() gets all the events affecting today. For each item => renderEvent() renders the HTML. HTML is passed back up the chain in reverse order, and appended to a string, until loop termination.

Filtering checkbox values for different types of change, statuses, and service providers are stored in local storage in the browser. I did this so that if the calendar were used with a frequently updated data set, a refresh interval could be set, and filtering preferences would persist (Thank you to James Hibbard for this post: https://www.sitepoint.com/quick-tip-persist-checkbox-checked-state-after-page-reload/). Statuses and types of change are static, because they are known for my purposes. Service provider checkboxes are dynamic and are determined and rendered on the fly, based on what events are occurring on the calendar, and which service owners are responsible for providing them. When page rendering is complete, event handlers are bound to the checkboxes so that whenever any of them change in value, the visibilityEvaluator() is run. This function sets every item that meets the criteria to $.show(), and sets everything else to $.hide(). The visibilityEvaluator() also unchecks any boxes used for email sharing to prevent user frustration/confusion when inadvertently sharing items that are filtered out of view.

The CSS is fairly self-explanatory. I have not yet implemented styles for many of the elements that are classed and id'd, but I built it so that it would be fairly easy to modify the styling to suit user preferences.

Ask me questions.
